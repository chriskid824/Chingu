import 'package:flutter_secure_storage/flutter_secure_storage.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:chingu/utils/encryption_helper.dart';

void main() {
  late EncryptionHelper encryptionHelper;

  setUp(() {
    // Initialize mock values for the platform interface.
    FlutterSecureStorage.setMockInitialValues({});
    encryptionHelper = EncryptionHelper();

    // Reset the singleton state for each test.
    // setStorage resets _isInitialized, _key, and _initFuture.
    encryptionHelper.setStorage(const FlutterSecureStorage());
  });

  test('EncryptionHelper generates and stores key on init', () async {
    await encryptionHelper.init();

    // Read directly from storage to verify persistence.
    const storage = FlutterSecureStorage();
    final key = await storage.read(key: 'secure_encryption_key');

    expect(key, isNotNull);
    expect(key!.isNotEmpty, true);
  });

  test('EncryptionHelper encrypts and decrypts correctly', () async {
    const plainText = 'This is a secret message';
    final encrypted = await encryptionHelper.encryptData(plainText);

    expect(encrypted, isNot(plainText));
    expect(encrypted, contains(':')); // Check IV format

    final decrypted = await encryptionHelper.decryptData(encrypted);
    expect(decrypted, plainText);
  });

  test('EncryptionHelper handles emoji and special characters', () async {
    const plainText = r'Hello ðŸŒ! This contains symbols: @#$%^&*()';
    final encrypted = await encryptionHelper.encryptData(plainText);
    final decrypted = await encryptionHelper.decryptData(encrypted);
    expect(decrypted, plainText);
  });

  test('EncryptionHelper handles concurrent init calls gracefully', () async {
    // Simulate multiple concurrent calls requiring initialization
    final futures = List.generate(10, (i) => encryptionHelper.encryptData('data$i'));

    final results = await Future.wait(futures);

    expect(results.length, 10);
    for (var res in results) {
      expect(res, contains(':'));
    }

    // Verify all can be decrypted (meaning they used the same key generated by the first winner)
    for (int i = 0; i < 10; i++) {
      final decrypted = await encryptionHelper.decryptData(results[i]);
      expect(decrypted, 'data$i');
    }
  });
}
