import 'dart:convert';
import 'dart:io';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:http/http.dart' as http;
import 'package:device_info_plus/device_info_plus.dart';
import 'package:chingu/models/login_history_model.dart';
import 'package:flutter/foundation.dart';

class LoginHistoryService {
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  final DeviceInfoPlugin _deviceInfo = DeviceInfoPlugin();

  /// Records a new login event for the given user.
  Future<void> recordLogin(String userId) async {
    try {
      final deviceInfo = await _getDeviceInfo();
      final locationInfo = await _getLocationInfo();

      final history = LoginHistoryModel(
        id: '', // Generated by Firestore
        timestamp: DateTime.now(),
        ipAddress: locationInfo['ip'] ?? 'Unknown',
        location: locationInfo['location'] ?? 'Unknown',
        device: deviceInfo,
      );

      await _firestore
          .collection('users')
          .doc(userId)
          .collection('login_history')
          .add(history.toMap());
    } catch (e) {
      debugPrint('Error recording login history: $e');
    }
  }

  /// Fetches the login history for a user, ordered by timestamp descending.
  Stream<List<LoginHistoryModel>> getLoginHistory(String userId) {
    return _firestore
        .collection('users')
        .doc(userId)
        .collection('login_history')
        .orderBy('timestamp', descending: true)
        .snapshots()
        .map((snapshot) {
      return snapshot.docs
          .map((doc) => LoginHistoryModel.fromFirestore(doc))
          .toList();
    });
  }

  Future<String> _getDeviceInfo() async {
    try {
      if (Platform.isAndroid) {
        final androidInfo = await _deviceInfo.androidInfo;
        return '${androidInfo.brand} ${androidInfo.model} (Android ${androidInfo.version.release})';
      } else if (Platform.isIOS) {
        final iosInfo = await _deviceInfo.iosInfo;
        return '${iosInfo.name} ${iosInfo.systemName} ${iosInfo.systemVersion}';
      } else if (Platform.isMacOS) {
        final macInfo = await _deviceInfo.macOsInfo;
        return '${macInfo.model} (macOS ${macInfo.osRelease})';
      } else if (Platform.isWindows) {
        final windowsInfo = await _deviceInfo.windowsInfo;
        return 'Windows ${windowsInfo.productName}';
      } else if (Platform.isLinux) {
        final linuxInfo = await _deviceInfo.linuxInfo;
        return 'Linux ${linuxInfo.prettyName}';
      } else {
        return 'Unknown Platform';
      }
    } catch (e) {
      debugPrint('Error getting device info: $e');
      return 'Unknown Device';
    }
  }

  Future<Map<String, String>> _getLocationInfo() async {
    try {
      // Using ipwho.is which supports HTTPS and doesn't require an API key
      final response = await http.get(Uri.parse('https://ipwho.is/'));
      if (response.statusCode == 200) {
        final data = json.decode(response.body);
        if (data['success'] == true) {
          final city = data['city'] ?? '';
          final country = data['country'] ?? '';
          final ip = data['ip'] ?? '';

          String location = '';
          if (city.isNotEmpty && country.isNotEmpty) {
            location = '$city, $country';
          } else {
            location = country.isNotEmpty ? country : 'Unknown';
          }

          return {
            'ip': ip,
            'location': location,
          };
        }
      }
    } catch (e) {
      debugPrint('Error fetching location info: $e');
    }
    return {
      'ip': 'Unknown',
      'location': 'Unknown',
    };
  }
}
