import 'dart:async';
import 'package:firebase_core/firebase_core.dart';
import 'package:firebase_messaging/firebase_messaging.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter/material.dart';
import '../firebase_options.dart';
import '../models/notification_model.dart';
import 'notification_storage_service.dart';
import '../widgets/in_app_notification.dart';
import '../core/routes/app_router.dart';

@pragma('vm:entry-point')
Future<void> _firebaseMessagingBackgroundHandler(RemoteMessage message) async {
  await Firebase.initializeApp(options: DefaultFirebaseOptions.currentPlatform);
  // Background message handling is typically managed by the system tray.
}

class NotificationService {
  static final NotificationService _instance = NotificationService._internal();

  factory NotificationService() {
    return _instance;
  }

  NotificationService._internal();

  final FirebaseMessaging _messaging = FirebaseMessaging.instance;
  bool _isInitialized = false;

  Future<void> initialize() async {
    if (_isInitialized) return;

    // Request permission
    await _messaging.requestPermission(
      alert: true,
      badge: true,
      sound: true,
      provisional: false,
    );

    // Set background handler
    FirebaseMessaging.onBackgroundMessage(_firebaseMessagingBackgroundHandler);

    // Foreground handler
    FirebaseMessaging.onMessage.listen(_handleForegroundMessage);

    // Handle initial message (terminated state)
    // RemoteMessage? initialMessage = await _messaging.getInitialMessage();
    // if (initialMessage != null) {
    //   _handleForegroundMessage(initialMessage);
    // }

    _isInitialized = true;
  }

  Future<void> _handleForegroundMessage(RemoteMessage message) async {
    final user = FirebaseAuth.instance.currentUser;
    if (user == null) return;

    // Convert RemoteMessage to NotificationModel
    final notification = _messageToModel(message, user.uid);

    // Save to Firestore
    try {
      await NotificationStorageService().saveNotification(notification);
    } catch (e) {
      debugPrint('Error saving notification: $e');
    }

    // Show InAppNotification
    _showInAppNotification(notification);
  }

  NotificationModel _messageToModel(RemoteMessage message, String userId) {
    // Extract data
    final data = message.data;
    final remoteNotification = message.notification;

    final title = remoteNotification?.title ?? data['title'] ?? 'New Notification';
    final body = remoteNotification?.body ?? data['message'] ?? '';
    final type = data['type'] ?? 'system';
    final imageUrl = data['imageUrl'] ?? data['image'];
    final actionType = data['actionType'] ?? data['click_action'];
    final actionData = data['actionData'] ?? data['id'];

    return NotificationModel(
      id: '', // Will be generated by Firestore
      userId: userId,
      type: type,
      title: title,
      message: body,
      imageUrl: imageUrl,
      actionType: actionType,
      actionData: actionData,
      isRead: false,
      createdAt: DateTime.now(),
    );
  }

  void _showInAppNotification(NotificationModel notification) {
    final context = AppRouter.navigatorKey.currentContext;
    if (context == null) return;

    final overlayState = AppRouter.navigatorKey.currentState?.overlay;
    if (overlayState == null) return;

    late OverlayEntry overlayEntry;
    Timer? dismissTimer;

    void dismiss() {
      dismissTimer?.cancel();
      overlayEntry.remove();
    }

    overlayEntry = OverlayEntry(
      builder: (context) => Positioned(
        top: 0,
        left: 0,
        right: 0,
        child: Material(
          color: Colors.transparent,
          child: InAppNotification(
            notification: notification,
            onDismiss: dismiss,
            onTap: () {
              _handleNotificationTap(notification);
              dismiss();
            },
          ),
        ),
      ),
    );

    overlayState.insert(overlayEntry);

    // Auto dismiss after 4 seconds
    dismissTimer = Timer(const Duration(seconds: 4), () {
      dismiss();
    });
  }

  void _handleNotificationTap(NotificationModel notification) {
    final navigator = AppRouter.navigatorKey.currentState;
    if (navigator == null) return;

    if (notification.actionType == 'open_chat') {
        navigator.pushNamed(AppRoutes.chatList);
    } else if (notification.actionType == 'view_event') {
        navigator.pushNamed(AppRoutes.eventDetail);
    } else if (notification.actionType == 'match_history') {
        navigator.pushNamed(AppRoutes.matchesList);
    } else {
        navigator.pushNamed(AppRoutes.notifications);
    }
  }
}
