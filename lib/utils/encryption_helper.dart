import 'dart:convert';
import 'package:encrypt/encrypt.dart' as encrypt;
import 'package:flutter_secure_storage/flutter_secure_storage.dart';
import 'package:flutter/foundation.dart';

/// Helper class for encrypting and decrypting sensitive data using AES.
/// Uses FlutterSecureStorage to securely manage the encryption key.
class EncryptionHelper {
  // Singleton pattern
  static final EncryptionHelper _instance = EncryptionHelper._internal();
  factory EncryptionHelper() => _instance;
  EncryptionHelper._internal() : _storage = const FlutterSecureStorage();

  final FlutterSecureStorage _storage;
  static const _keyStorageKey = 'app_encryption_key';

  encrypt.Key? _key;

  @visibleForTesting
  EncryptionHelper.test({required FlutterSecureStorage storage}) : _storage = storage;

  /// Initialize the helper. Must be called before encrypt/decrypt.
  ///
  /// Checks for an existing key in secure storage. If not found,
  /// generates a new random 256-bit key and saves it.
  Future<void> init() async {
    if (_key != null) return;

    try {
      String? keyString = await _storage.read(key: _keyStorageKey);

      if (keyString == null) {
        // Generate a new 32 bytes (256 bit) key
        final key = encrypt.Key.fromSecureRandom(32);
        keyString = base64Url.encode(key.bytes);
        await _storage.write(key: _keyStorageKey, value: keyString);
        _key = key;
        debugPrint('EncryptionHelper: New key generated and saved.');
      } else {
        _key = encrypt.Key(base64Url.decode(keyString));
        debugPrint('EncryptionHelper: Key loaded from storage.');
      }
    } catch (e) {
      debugPrint('EncryptionHelper: Error initializing key: $e');
      rethrow;
    }
  }

  /// Encrypts a string. Returns base64 encoded string containing IV and Ciphertext.
  /// Format: "iv_base64:ciphertext_base64"
  String encryptData(String plainText) {
    if (_key == null) {
      throw StateError('EncryptionHelper not initialized. Call init() first.');
    }

    final iv = encrypt.IV.fromSecureRandom(16); // AES block size is 16 bytes
    final encrypter = encrypt.Encrypter(encrypt.AES(_key!, mode: encrypt.AESMode.cbc));

    final encrypted = encrypter.encrypt(plainText, iv: iv);

    return '${iv.base64}:${encrypted.base64}';
  }

  /// Decrypts a string. Expects format generated by [encryptData].
  String decryptData(String encryptedText) {
    if (_key == null) {
      throw StateError('EncryptionHelper not initialized. Call init() first.');
    }

    try {
      final parts = encryptedText.split(':');
      if (parts.length != 2) {
        throw FormatException('Invalid encrypted text format');
      }

      final iv = encrypt.IV.fromBase64(parts[0]);
      final encrypted = encrypt.Encrypted.fromBase64(parts[1]);

      final encrypter = encrypt.Encrypter(encrypt.AES(_key!, mode: encrypt.AESMode.cbc));

      return encrypter.decrypt(encrypted, iv: iv);
    } catch (e) {
      debugPrint('EncryptionHelper: Decryption failed: $e');
      throw Exception('Decryption failed: $e');
    }
  }

  /// Reset the key (for testing or key rotation).
  /// Warning: This will make previously encrypted data undecryptable.
  @visibleForTesting
  Future<void> clearKey() async {
    _key = null;
    await _storage.delete(key: _keyStorageKey);
  }
}
